// Code generated by ogen, DO NOT EDIT.

package client

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddGroupMemberV1 invokes addGroupMemberV1 operation.
	//
	// Add Group Member.
	//
	// PUT /api/admin/v1/groups/{id}/members/{email}
	AddGroupMemberV1(ctx context.Context, params AddGroupMemberV1Params) error
	// CreateAccessFlowV2 invokes createAccessFlowV2 operation.
	//
	// Create access flow.
	//
	// POST /api/admin/v2/access-flows
	CreateAccessFlowV2(ctx context.Context, request *AccessFlowUpsertPublicV2Model) (*AccessFlowPublicV2Model, error)
	// CreateAccessScopesV1 invokes createAccessScopesV1 operation.
	//
	// Create Access Scope.
	//
	// POST /api/admin/v1/access-scopes
	CreateAccessScopesV1(ctx context.Context, request *UpsertAccessScopeV1) (*AccessScopeV1, error)
	// CreateBundleV2 invokes createBundleV2 operation.
	//
	// Create Bundle.
	//
	// POST /api/admin/v2/bundles
	CreateBundleV2(ctx context.Context, request *UpsertBundlePublicV2Model) (*BundlePublicV2Model, error)
	// CreateGroupV1 invokes createGroupV1 operation.
	//
	// Create Group.
	//
	// POST /api/admin/v1/groups
	CreateGroupV1(ctx context.Context, request *CreateGroupV1) (*GroupV1, error)
	// CreateIntegrationV4 invokes createIntegrationV4 operation.
	//
	// Create integration.
	//
	// POST /api/admin/v4/integrations
	CreateIntegrationV4(ctx context.Context, request *CreateIntegrationV4) (*IntegrationV4, error)
	// DeleteAccessFlowV2 invokes deleteAccessFlowV2 operation.
	//
	// Delete access flow.
	//
	// DELETE /api/admin/v2/access-flows/{id}
	DeleteAccessFlowV2(ctx context.Context, params DeleteAccessFlowV2Params) error
	// DeleteAccessScopesV1 invokes deleteAccessScopesV1 operation.
	//
	// Delete Access Scope.
	//
	// DELETE /api/admin/v1/access-scopes/{id}
	DeleteAccessScopesV1(ctx context.Context, params DeleteAccessScopesV1Params) error
	// DeleteBundleV2 invokes deleteBundleV2 operation.
	//
	// Delete Bundle.
	//
	// DELETE /api/admin/v2/bundles/{id}
	DeleteBundleV2(ctx context.Context, params DeleteBundleV2Params) error
	// DeleteConnectorV3 invokes deleteConnectorV3 operation.
	//
	// Delete Connector.
	//
	// DELETE /api/admin/v3/connectors/{id}
	DeleteConnectorV3(ctx context.Context, params DeleteConnectorV3Params) error
	// DeleteGroupV1 invokes deleteGroupV1 operation.
	//
	// Delete Group.
	//
	// DELETE /api/admin/v1/groups/{id}
	DeleteGroupV1(ctx context.Context, params DeleteGroupV1Params) error
	// DeleteIntegrationV4 invokes deleteIntegrationV4 operation.
	//
	// Delete integration.
	//
	// DELETE /api/admin/v4/integrations/{id}
	DeleteIntegrationV4(ctx context.Context, params DeleteIntegrationV4Params) error
	// GetAccessFlowV2 invokes getAccessFlowV2 operation.
	//
	// Get access flow.
	//
	// GET /api/admin/v2/access-flows/{id}
	GetAccessFlowV2(ctx context.Context, params GetAccessFlowV2Params) (*AccessFlowPublicV2Model, error)
	// GetAccessScopesV1 invokes getAccessScopesV1 operation.
	//
	// Get Access Scope.
	//
	// GET /api/admin/v1/access-scopes/{id}
	GetAccessScopesV1(ctx context.Context, params GetAccessScopesV1Params) (*AccessScopeV1, error)
	// GetBundleV2 invokes getBundleV2 operation.
	//
	// Get Bundle.
	//
	// GET /api/admin/v2/bundles/{id}
	GetBundleV2(ctx context.Context, params GetBundleV2Params) (*BundlePublicV2Model, error)
	// GetConnectorV3 invokes getConnectorV3 operation.
	//
	// Get Connector.
	//
	// GET /api/admin/v3/connectors/{id}
	GetConnectorV3(ctx context.Context, params GetConnectorV3Params) (*ConnectorV3, error)
	// GetGroupV1 invokes getGroupV1 operation.
	//
	// Get Group.
	//
	// GET /api/admin/v1/groups/{id}
	GetGroupV1(ctx context.Context, params GetGroupV1Params) (*GroupV1, error)
	// GetIntegrationsByIdV4 invokes getIntegrationsByIdV4 operation.
	//
	// Get integration by id.
	//
	// GET /api/admin/v4/integrations/{id}
	GetIntegrationsByIdV4(ctx context.Context, params GetIntegrationsByIdV4Params) (*IntegrationV4, error)
	// GetUser invokes getUser operation.
	//
	// Get user by Id or Email.
	//
	// GET /api/v2/users/{id}
	GetUser(ctx context.Context, params GetUserParams) (*UserModel, error)
	// ListAccessFlowsV2 invokes listAccessFlowsV2 operation.
	//
	// List access flows.
	//
	// GET /api/admin/v2/access-flows
	ListAccessFlowsV2(ctx context.Context, params ListAccessFlowsV2Params) (*PublicApiListResponseAccessFlowPublicV2Model, error)
	// ListAccessScopesV1 invokes listAccessScopesV1 operation.
	//
	// List Access Scopes.
	//
	// GET /api/admin/v1/access-scopes
	ListAccessScopesV1(ctx context.Context, params ListAccessScopesV1Params) (*PublicApiListResponseAccessScopePublicV1Model, error)
	// ListBundlesV2 invokes listBundlesV2 operation.
	//
	// List Bundles.
	//
	// GET /api/admin/v2/bundles
	ListBundlesV2(ctx context.Context, params ListBundlesV2Params) (*PublicApiListResponseBundlePublicV2Model, error)
	// ListConnectorsV3 invokes listConnectorsV3 operation.
	//
	// List Connectors.
	//
	// GET /api/admin/v3/connectors
	ListConnectorsV3(ctx context.Context, params ListConnectorsV3Params) (*PublicApiListResponseConnectorPublicV3Model, error)
	// ListGroupMembersV1 invokes listGroupMembersV1 operation.
	//
	// Get Group Members.
	//
	// GET /api/admin/v1/groups/{id}/members
	ListGroupMembersV1(ctx context.Context, params ListGroupMembersV1Params) (*PublicApiListResponseGroupMemberPublicV1Model, error)
	// ListGroupsV1 invokes listGroupsV1 operation.
	//
	// List Groups.
	//
	// GET /api/admin/v1/groups
	ListGroupsV1(ctx context.Context, params ListGroupsV1Params) (*PublicApiListResponseGroupPublicV1Model, error)
	// ListIntegrationsV4 invokes listIntegrationsV4 operation.
	//
	// List integrations.
	//
	// GET /api/admin/v4/integrations
	ListIntegrationsV4(ctx context.Context, params ListIntegrationsV4Params) (*PublicApiListResponseIntegrationPublicV4Model, error)
	// ListUsers invokes listUsers operation.
	//
	// List users.
	//
	// GET /api/v2/users
	ListUsers(ctx context.Context) (*PaginatedResponseUserModel, error)
	// RemoveGroupMemberV1 invokes removeGroupMemberV1 operation.
	//
	// Remove Group Member.
	//
	// DELETE /api/admin/v1/groups/{id}/members/{email}
	RemoveGroupMemberV1(ctx context.Context, params RemoveGroupMemberV1Params) error
	// UpdateAccessFlowV2 invokes updateAccessFlowV2 operation.
	//
	// Update access flow.
	//
	// PUT /api/admin/v2/access-flows/{id}
	UpdateAccessFlowV2(ctx context.Context, request *AccessFlowUpsertPublicV2Model, params UpdateAccessFlowV2Params) (*AccessFlowPublicV2Model, error)
	// UpdateAccessScopesV1 invokes updateAccessScopesV1 operation.
	//
	// Update Access Scope.
	//
	// PUT /api/admin/v1/access-scopes/{id}
	UpdateAccessScopesV1(ctx context.Context, request *UpsertAccessScopeV1, params UpdateAccessScopesV1Params) (*AccessScopeV1, error)
	// UpdateBundleV2 invokes updateBundleV2 operation.
	//
	// Update Bundle.
	//
	// PUT /api/admin/v2/bundles/{id}
	UpdateBundleV2(ctx context.Context, request *UpsertBundlePublicV2Model, params UpdateBundleV2Params) (*BundlePublicV2Model, error)
	// UpdateConnectorV3 invokes updateConnectorV3 operation.
	//
	// Update Connector.
	//
	// PUT /api/admin/v3/connectors/{id}
	UpdateConnectorV3(ctx context.Context, request *UpsertConnectorV3, params UpdateConnectorV3Params) (*ConnectorV3, error)
	// UpdateGroupMembersV1 invokes updateGroupMembersV1 operation.
	//
	// Update Group Members.
	//
	// PUT /api/admin/v1/groups/{id}/members
	UpdateGroupMembersV1(ctx context.Context, request *UpdateGroupMembersV1, params UpdateGroupMembersV1Params) error
	// UpdateGroupV1 invokes updateGroupV1 operation.
	//
	// Update Group.
	//
	// PUT /api/admin/v1/groups/{id}/name
	UpdateGroupV1(ctx context.Context, request *UpdateGroupV1, params UpdateGroupV1Params) (*GroupV1, error)
	// UpdateIntegrationV4 invokes updateIntegrationV4 operation.
	//
	// Update integration.
	//
	// PUT /api/admin/v4/integrations/{id}
	UpdateIntegrationV4(ctx context.Context, request *UpdateIntegrationV4, params UpdateIntegrationV4Params) (*IntegrationV4, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddGroupMemberV1 invokes addGroupMemberV1 operation.
//
// Add Group Member.
//
// PUT /api/admin/v1/groups/{id}/members/{email}
func (c *Client) AddGroupMemberV1(ctx context.Context, params AddGroupMemberV1Params) error {
	_, err := c.sendAddGroupMemberV1(ctx, params)
	return err
}

func (c *Client) sendAddGroupMemberV1(ctx context.Context, params AddGroupMemberV1Params) (res *AddGroupMemberV1NoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/admin/v1/groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "email" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "email",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Email))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, AddGroupMemberV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddGroupMemberV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAccessFlowV2 invokes createAccessFlowV2 operation.
//
// Create access flow.
//
// POST /api/admin/v2/access-flows
func (c *Client) CreateAccessFlowV2(ctx context.Context, request *AccessFlowUpsertPublicV2Model) (*AccessFlowPublicV2Model, error) {
	res, err := c.sendCreateAccessFlowV2(ctx, request)
	return res, err
}

func (c *Client) sendCreateAccessFlowV2(ctx context.Context, request *AccessFlowUpsertPublicV2Model) (res *AccessFlowPublicV2Model, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v2/access-flows"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAccessFlowV2Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, CreateAccessFlowV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateAccessFlowV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAccessScopesV1 invokes createAccessScopesV1 operation.
//
// Create Access Scope.
//
// POST /api/admin/v1/access-scopes
func (c *Client) CreateAccessScopesV1(ctx context.Context, request *UpsertAccessScopeV1) (*AccessScopeV1, error) {
	res, err := c.sendCreateAccessScopesV1(ctx, request)
	return res, err
}

func (c *Client) sendCreateAccessScopesV1(ctx context.Context, request *UpsertAccessScopeV1) (res *AccessScopeV1, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v1/access-scopes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAccessScopesV1Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, CreateAccessScopesV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateAccessScopesV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateBundleV2 invokes createBundleV2 operation.
//
// Create Bundle.
//
// POST /api/admin/v2/bundles
func (c *Client) CreateBundleV2(ctx context.Context, request *UpsertBundlePublicV2Model) (*BundlePublicV2Model, error) {
	res, err := c.sendCreateBundleV2(ctx, request)
	return res, err
}

func (c *Client) sendCreateBundleV2(ctx context.Context, request *UpsertBundlePublicV2Model) (res *BundlePublicV2Model, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v2/bundles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateBundleV2Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, CreateBundleV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateBundleV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateGroupV1 invokes createGroupV1 operation.
//
// Create Group.
//
// POST /api/admin/v1/groups
func (c *Client) CreateGroupV1(ctx context.Context, request *CreateGroupV1) (*GroupV1, error) {
	res, err := c.sendCreateGroupV1(ctx, request)
	return res, err
}

func (c *Client) sendCreateGroupV1(ctx context.Context, request *CreateGroupV1) (res *GroupV1, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v1/groups"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateGroupV1Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, CreateGroupV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateGroupV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateIntegrationV4 invokes createIntegrationV4 operation.
//
// Create integration.
//
// POST /api/admin/v4/integrations
func (c *Client) CreateIntegrationV4(ctx context.Context, request *CreateIntegrationV4) (*IntegrationV4, error) {
	res, err := c.sendCreateIntegrationV4(ctx, request)
	return res, err
}

func (c *Client) sendCreateIntegrationV4(ctx context.Context, request *CreateIntegrationV4) (res *IntegrationV4, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v4/integrations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateIntegrationV4Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, CreateIntegrationV4Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateIntegrationV4Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAccessFlowV2 invokes deleteAccessFlowV2 operation.
//
// Delete access flow.
//
// DELETE /api/admin/v2/access-flows/{id}
func (c *Client) DeleteAccessFlowV2(ctx context.Context, params DeleteAccessFlowV2Params) error {
	_, err := c.sendDeleteAccessFlowV2(ctx, params)
	return err
}

func (c *Client) sendDeleteAccessFlowV2(ctx context.Context, params DeleteAccessFlowV2Params) (res *DeleteAccessFlowV2NoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v2/access-flows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, DeleteAccessFlowV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAccessFlowV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAccessScopesV1 invokes deleteAccessScopesV1 operation.
//
// Delete Access Scope.
//
// DELETE /api/admin/v1/access-scopes/{id}
func (c *Client) DeleteAccessScopesV1(ctx context.Context, params DeleteAccessScopesV1Params) error {
	_, err := c.sendDeleteAccessScopesV1(ctx, params)
	return err
}

func (c *Client) sendDeleteAccessScopesV1(ctx context.Context, params DeleteAccessScopesV1Params) (res *DeleteAccessScopesV1NoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v1/access-scopes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, DeleteAccessScopesV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAccessScopesV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteBundleV2 invokes deleteBundleV2 operation.
//
// Delete Bundle.
//
// DELETE /api/admin/v2/bundles/{id}
func (c *Client) DeleteBundleV2(ctx context.Context, params DeleteBundleV2Params) error {
	_, err := c.sendDeleteBundleV2(ctx, params)
	return err
}

func (c *Client) sendDeleteBundleV2(ctx context.Context, params DeleteBundleV2Params) (res *DeleteBundleV2NoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v2/bundles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, DeleteBundleV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteBundleV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteConnectorV3 invokes deleteConnectorV3 operation.
//
// Delete Connector.
//
// DELETE /api/admin/v3/connectors/{id}
func (c *Client) DeleteConnectorV3(ctx context.Context, params DeleteConnectorV3Params) error {
	_, err := c.sendDeleteConnectorV3(ctx, params)
	return err
}

func (c *Client) sendDeleteConnectorV3(ctx context.Context, params DeleteConnectorV3Params) (res *DeleteConnectorV3NoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v3/connectors/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, DeleteConnectorV3Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteConnectorV3Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteGroupV1 invokes deleteGroupV1 operation.
//
// Delete Group.
//
// DELETE /api/admin/v1/groups/{id}
func (c *Client) DeleteGroupV1(ctx context.Context, params DeleteGroupV1Params) error {
	_, err := c.sendDeleteGroupV1(ctx, params)
	return err
}

func (c *Client) sendDeleteGroupV1(ctx context.Context, params DeleteGroupV1Params) (res *DeleteGroupV1NoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v1/groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, DeleteGroupV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteGroupV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteIntegrationV4 invokes deleteIntegrationV4 operation.
//
// Delete integration.
//
// DELETE /api/admin/v4/integrations/{id}
func (c *Client) DeleteIntegrationV4(ctx context.Context, params DeleteIntegrationV4Params) error {
	_, err := c.sendDeleteIntegrationV4(ctx, params)
	return err
}

func (c *Client) sendDeleteIntegrationV4(ctx context.Context, params DeleteIntegrationV4Params) (res *DeleteIntegrationV4NoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v4/integrations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, DeleteIntegrationV4Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteIntegrationV4Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccessFlowV2 invokes getAccessFlowV2 operation.
//
// Get access flow.
//
// GET /api/admin/v2/access-flows/{id}
func (c *Client) GetAccessFlowV2(ctx context.Context, params GetAccessFlowV2Params) (*AccessFlowPublicV2Model, error) {
	res, err := c.sendGetAccessFlowV2(ctx, params)
	return res, err
}

func (c *Client) sendGetAccessFlowV2(ctx context.Context, params GetAccessFlowV2Params) (res *AccessFlowPublicV2Model, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v2/access-flows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, GetAccessFlowV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAccessFlowV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccessScopesV1 invokes getAccessScopesV1 operation.
//
// Get Access Scope.
//
// GET /api/admin/v1/access-scopes/{id}
func (c *Client) GetAccessScopesV1(ctx context.Context, params GetAccessScopesV1Params) (*AccessScopeV1, error) {
	res, err := c.sendGetAccessScopesV1(ctx, params)
	return res, err
}

func (c *Client) sendGetAccessScopesV1(ctx context.Context, params GetAccessScopesV1Params) (res *AccessScopeV1, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v1/access-scopes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, GetAccessScopesV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAccessScopesV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBundleV2 invokes getBundleV2 operation.
//
// Get Bundle.
//
// GET /api/admin/v2/bundles/{id}
func (c *Client) GetBundleV2(ctx context.Context, params GetBundleV2Params) (*BundlePublicV2Model, error) {
	res, err := c.sendGetBundleV2(ctx, params)
	return res, err
}

func (c *Client) sendGetBundleV2(ctx context.Context, params GetBundleV2Params) (res *BundlePublicV2Model, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v2/bundles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, GetBundleV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBundleV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConnectorV3 invokes getConnectorV3 operation.
//
// Get Connector.
//
// GET /api/admin/v3/connectors/{id}
func (c *Client) GetConnectorV3(ctx context.Context, params GetConnectorV3Params) (*ConnectorV3, error) {
	res, err := c.sendGetConnectorV3(ctx, params)
	return res, err
}

func (c *Client) sendGetConnectorV3(ctx context.Context, params GetConnectorV3Params) (res *ConnectorV3, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v3/connectors/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, GetConnectorV3Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetConnectorV3Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGroupV1 invokes getGroupV1 operation.
//
// Get Group.
//
// GET /api/admin/v1/groups/{id}
func (c *Client) GetGroupV1(ctx context.Context, params GetGroupV1Params) (*GroupV1, error) {
	res, err := c.sendGetGroupV1(ctx, params)
	return res, err
}

func (c *Client) sendGetGroupV1(ctx context.Context, params GetGroupV1Params) (res *GroupV1, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v1/groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, GetGroupV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetGroupV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetIntegrationsByIdV4 invokes getIntegrationsByIdV4 operation.
//
// Get integration by id.
//
// GET /api/admin/v4/integrations/{id}
func (c *Client) GetIntegrationsByIdV4(ctx context.Context, params GetIntegrationsByIdV4Params) (*IntegrationV4, error) {
	res, err := c.sendGetIntegrationsByIdV4(ctx, params)
	return res, err
}

func (c *Client) sendGetIntegrationsByIdV4(ctx context.Context, params GetIntegrationsByIdV4Params) (res *IntegrationV4, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v4/integrations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, GetIntegrationsByIdV4Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetIntegrationsByIdV4Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUser invokes getUser operation.
//
// Get user by Id or Email.
//
// GET /api/v2/users/{id}
func (c *Client) GetUser(ctx context.Context, params GetUserParams) (*UserModel, error) {
	res, err := c.sendGetUser(ctx, params)
	return res, err
}

func (c *Client) sendGetUser(ctx context.Context, params GetUserParams) (res *UserModel, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/users/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, GetUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAccessFlowsV2 invokes listAccessFlowsV2 operation.
//
// List access flows.
//
// GET /api/admin/v2/access-flows
func (c *Client) ListAccessFlowsV2(ctx context.Context, params ListAccessFlowsV2Params) (*PublicApiListResponseAccessFlowPublicV2Model, error) {
	res, err := c.sendListAccessFlowsV2(ctx, params)
	return res, err
}

func (c *Client) sendListAccessFlowsV2(ctx context.Context, params ListAccessFlowsV2Params) (res *PublicApiListResponseAccessFlowPublicV2Model, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v2/access-flows"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ListAccessFlowsV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListAccessFlowsV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAccessScopesV1 invokes listAccessScopesV1 operation.
//
// List Access Scopes.
//
// GET /api/admin/v1/access-scopes
func (c *Client) ListAccessScopesV1(ctx context.Context, params ListAccessScopesV1Params) (*PublicApiListResponseAccessScopePublicV1Model, error) {
	res, err := c.sendListAccessScopesV1(ctx, params)
	return res, err
}

func (c *Client) sendListAccessScopesV1(ctx context.Context, params ListAccessScopesV1Params) (res *PublicApiListResponseAccessScopePublicV1Model, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v1/access-scopes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ListAccessScopesV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListAccessScopesV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListBundlesV2 invokes listBundlesV2 operation.
//
// List Bundles.
//
// GET /api/admin/v2/bundles
func (c *Client) ListBundlesV2(ctx context.Context, params ListBundlesV2Params) (*PublicApiListResponseBundlePublicV2Model, error) {
	res, err := c.sendListBundlesV2(ctx, params)
	return res, err
}

func (c *Client) sendListBundlesV2(ctx context.Context, params ListBundlesV2Params) (res *PublicApiListResponseBundlePublicV2Model, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v2/bundles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ListBundlesV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListBundlesV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListConnectorsV3 invokes listConnectorsV3 operation.
//
// List Connectors.
//
// GET /api/admin/v3/connectors
func (c *Client) ListConnectorsV3(ctx context.Context, params ListConnectorsV3Params) (*PublicApiListResponseConnectorPublicV3Model, error) {
	res, err := c.sendListConnectorsV3(ctx, params)
	return res, err
}

func (c *Client) sendListConnectorsV3(ctx context.Context, params ListConnectorsV3Params) (res *PublicApiListResponseConnectorPublicV3Model, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v3/connectors"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ListConnectorsV3Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListConnectorsV3Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListGroupMembersV1 invokes listGroupMembersV1 operation.
//
// Get Group Members.
//
// GET /api/admin/v1/groups/{id}/members
func (c *Client) ListGroupMembersV1(ctx context.Context, params ListGroupMembersV1Params) (*PublicApiListResponseGroupMemberPublicV1Model, error) {
	res, err := c.sendListGroupMembersV1(ctx, params)
	return res, err
}

func (c *Client) sendListGroupMembersV1(ctx context.Context, params ListGroupMembersV1Params) (res *PublicApiListResponseGroupMemberPublicV1Model, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/admin/v1/groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ListGroupMembersV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListGroupMembersV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListGroupsV1 invokes listGroupsV1 operation.
//
// List Groups.
//
// GET /api/admin/v1/groups
func (c *Client) ListGroupsV1(ctx context.Context, params ListGroupsV1Params) (*PublicApiListResponseGroupPublicV1Model, error) {
	res, err := c.sendListGroupsV1(ctx, params)
	return res, err
}

func (c *Client) sendListGroupsV1(ctx context.Context, params ListGroupsV1Params) (res *PublicApiListResponseGroupPublicV1Model, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v1/groups"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ListGroupsV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListGroupsV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListIntegrationsV4 invokes listIntegrationsV4 operation.
//
// List integrations.
//
// GET /api/admin/v4/integrations
func (c *Client) ListIntegrationsV4(ctx context.Context, params ListIntegrationsV4Params) (*PublicApiListResponseIntegrationPublicV4Model, error) {
	res, err := c.sendListIntegrationsV4(ctx, params)
	return res, err
}

func (c *Client) sendListIntegrationsV4(ctx context.Context, params ListIntegrationsV4Params) (res *PublicApiListResponseIntegrationPublicV4Model, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/admin/v4/integrations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Category.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "connector_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "connector_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ConnectorID.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ListIntegrationsV4Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListIntegrationsV4Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListUsers invokes listUsers operation.
//
// List users.
//
// GET /api/v2/users
func (c *Client) ListUsers(ctx context.Context) (*PaginatedResponseUserModel, error) {
	res, err := c.sendListUsers(ctx)
	return res, err
}

func (c *Client) sendListUsers(ctx context.Context) (res *PaginatedResponseUserModel, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ListUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveGroupMemberV1 invokes removeGroupMemberV1 operation.
//
// Remove Group Member.
//
// DELETE /api/admin/v1/groups/{id}/members/{email}
func (c *Client) RemoveGroupMemberV1(ctx context.Context, params RemoveGroupMemberV1Params) error {
	_, err := c.sendRemoveGroupMemberV1(ctx, params)
	return err
}

func (c *Client) sendRemoveGroupMemberV1(ctx context.Context, params RemoveGroupMemberV1Params) (res *RemoveGroupMemberV1NoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/admin/v1/groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "email" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "email",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Email))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, RemoveGroupMemberV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveGroupMemberV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAccessFlowV2 invokes updateAccessFlowV2 operation.
//
// Update access flow.
//
// PUT /api/admin/v2/access-flows/{id}
func (c *Client) UpdateAccessFlowV2(ctx context.Context, request *AccessFlowUpsertPublicV2Model, params UpdateAccessFlowV2Params) (*AccessFlowPublicV2Model, error) {
	res, err := c.sendUpdateAccessFlowV2(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAccessFlowV2(ctx context.Context, request *AccessFlowUpsertPublicV2Model, params UpdateAccessFlowV2Params) (res *AccessFlowPublicV2Model, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v2/access-flows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAccessFlowV2Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UpdateAccessFlowV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateAccessFlowV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAccessScopesV1 invokes updateAccessScopesV1 operation.
//
// Update Access Scope.
//
// PUT /api/admin/v1/access-scopes/{id}
func (c *Client) UpdateAccessScopesV1(ctx context.Context, request *UpsertAccessScopeV1, params UpdateAccessScopesV1Params) (*AccessScopeV1, error) {
	res, err := c.sendUpdateAccessScopesV1(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAccessScopesV1(ctx context.Context, request *UpsertAccessScopeV1, params UpdateAccessScopesV1Params) (res *AccessScopeV1, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v1/access-scopes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAccessScopesV1Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UpdateAccessScopesV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateAccessScopesV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBundleV2 invokes updateBundleV2 operation.
//
// Update Bundle.
//
// PUT /api/admin/v2/bundles/{id}
func (c *Client) UpdateBundleV2(ctx context.Context, request *UpsertBundlePublicV2Model, params UpdateBundleV2Params) (*BundlePublicV2Model, error) {
	res, err := c.sendUpdateBundleV2(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateBundleV2(ctx context.Context, request *UpsertBundlePublicV2Model, params UpdateBundleV2Params) (res *BundlePublicV2Model, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v2/bundles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBundleV2Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UpdateBundleV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBundleV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateConnectorV3 invokes updateConnectorV3 operation.
//
// Update Connector.
//
// PUT /api/admin/v3/connectors/{id}
func (c *Client) UpdateConnectorV3(ctx context.Context, request *UpsertConnectorV3, params UpdateConnectorV3Params) (*ConnectorV3, error) {
	res, err := c.sendUpdateConnectorV3(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateConnectorV3(ctx context.Context, request *UpsertConnectorV3, params UpdateConnectorV3Params) (res *ConnectorV3, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v3/connectors/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateConnectorV3Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UpdateConnectorV3Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateConnectorV3Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateGroupMembersV1 invokes updateGroupMembersV1 operation.
//
// Update Group Members.
//
// PUT /api/admin/v1/groups/{id}/members
func (c *Client) UpdateGroupMembersV1(ctx context.Context, request *UpdateGroupMembersV1, params UpdateGroupMembersV1Params) error {
	_, err := c.sendUpdateGroupMembersV1(ctx, request, params)
	return err
}

func (c *Client) sendUpdateGroupMembersV1(ctx context.Context, request *UpdateGroupMembersV1, params UpdateGroupMembersV1Params) (res *UpdateGroupMembersV1NoContent, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/admin/v1/groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateGroupMembersV1Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UpdateGroupMembersV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateGroupMembersV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateGroupV1 invokes updateGroupV1 operation.
//
// Update Group.
//
// PUT /api/admin/v1/groups/{id}/name
func (c *Client) UpdateGroupV1(ctx context.Context, request *UpdateGroupV1, params UpdateGroupV1Params) (*GroupV1, error) {
	res, err := c.sendUpdateGroupV1(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateGroupV1(ctx context.Context, request *UpdateGroupV1, params UpdateGroupV1Params) (res *GroupV1, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/admin/v1/groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/name"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateGroupV1Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UpdateGroupV1Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateGroupV1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateIntegrationV4 invokes updateIntegrationV4 operation.
//
// Update integration.
//
// PUT /api/admin/v4/integrations/{id}
func (c *Client) UpdateIntegrationV4(ctx context.Context, request *UpdateIntegrationV4, params UpdateIntegrationV4Params) (*IntegrationV4, error) {
	res, err := c.sendUpdateIntegrationV4(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateIntegrationV4(ctx context.Context, request *UpdateIntegrationV4, params UpdateIntegrationV4Params) (res *IntegrationV4, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/admin/v4/integrations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateIntegrationV4Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UpdateIntegrationV4Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateIntegrationV4Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
