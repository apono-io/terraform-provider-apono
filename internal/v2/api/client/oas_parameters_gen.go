// Code generated by ogen, DO NOT EDIT.

package client

import (
	"fmt"
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// AddGroupMemberV1Params is parameters of addGroupMemberV1 operation.
type AddGroupMemberV1Params struct {
	Email string
	ID    string
}

func unpackAddGroupMemberV1Params(packed middleware.Parameters) (params AddGroupMemberV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "email",
			In:   "path",
		}
		params.Email = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeAddGroupMemberV1Params(args [2]string, argsEscaped bool, r *http.Request) (params AddGroupMemberV1Params, _ error) {
	// Decode path: email.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "email",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Email = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "email",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAccessBundleParams is parameters of deleteAccessBundle operation.
type DeleteAccessBundleParams struct {
	ID string
}

func unpackDeleteAccessBundleParams(packed middleware.Parameters) (params DeleteAccessBundleParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteAccessBundleParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteAccessBundleParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAccessFlowV1Params is parameters of deleteAccessFlowV1 operation.
type DeleteAccessFlowV1Params struct {
	ID string
}

func unpackDeleteAccessFlowV1Params(packed middleware.Parameters) (params DeleteAccessFlowV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteAccessFlowV1Params(args [1]string, argsEscaped bool, r *http.Request) (params DeleteAccessFlowV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAccessFlowV2Params is parameters of deleteAccessFlowV2 operation.
type DeleteAccessFlowV2Params struct {
	ID string
}

func unpackDeleteAccessFlowV2Params(packed middleware.Parameters) (params DeleteAccessFlowV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteAccessFlowV2Params(args [1]string, argsEscaped bool, r *http.Request) (params DeleteAccessFlowV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAccessScopesV1Params is parameters of deleteAccessScopesV1 operation.
type DeleteAccessScopesV1Params struct {
	ID string
}

func unpackDeleteAccessScopesV1Params(packed middleware.Parameters) (params DeleteAccessScopesV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteAccessScopesV1Params(args [1]string, argsEscaped bool, r *http.Request) (params DeleteAccessScopesV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteBundleV2Params is parameters of deleteBundleV2 operation.
type DeleteBundleV2Params struct {
	ID string
}

func unpackDeleteBundleV2Params(packed middleware.Parameters) (params DeleteBundleV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteBundleV2Params(args [1]string, argsEscaped bool, r *http.Request) (params DeleteBundleV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteConnectorV3Params is parameters of deleteConnectorV3 operation.
type DeleteConnectorV3Params struct {
	ID string
}

func unpackDeleteConnectorV3Params(packed middleware.Parameters) (params DeleteConnectorV3Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteConnectorV3Params(args [1]string, argsEscaped bool, r *http.Request) (params DeleteConnectorV3Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteGroupV1Params is parameters of deleteGroupV1 operation.
type DeleteGroupV1Params struct {
	ID string
}

func unpackDeleteGroupV1Params(packed middleware.Parameters) (params DeleteGroupV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteGroupV1Params(args [1]string, argsEscaped bool, r *http.Request) (params DeleteGroupV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteIntegrationV2Params is parameters of deleteIntegrationV2 operation.
type DeleteIntegrationV2Params struct {
	ID string
}

func unpackDeleteIntegrationV2Params(packed middleware.Parameters) (params DeleteIntegrationV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteIntegrationV2Params(args [1]string, argsEscaped bool, r *http.Request) (params DeleteIntegrationV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteIntegrationV4Params is parameters of deleteIntegrationV4 operation.
type DeleteIntegrationV4Params struct {
	ID string
}

func unpackDeleteIntegrationV4Params(packed middleware.Parameters) (params DeleteIntegrationV4Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteIntegrationV4Params(args [1]string, argsEscaped bool, r *http.Request) (params DeleteIntegrationV4Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessBundleParams is parameters of getAccessBundle operation.
type GetAccessBundleParams struct {
	ID string
}

func unpackGetAccessBundleParams(packed middleware.Parameters) (params GetAccessBundleParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAccessBundleParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessBundleParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessFlowV1Params is parameters of getAccessFlowV1 operation.
type GetAccessFlowV1Params struct {
	ID string
}

func unpackGetAccessFlowV1Params(packed middleware.Parameters) (params GetAccessFlowV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAccessFlowV1Params(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessFlowV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessFlowV2Params is parameters of getAccessFlowV2 operation.
type GetAccessFlowV2Params struct {
	ID string
}

func unpackGetAccessFlowV2Params(packed middleware.Parameters) (params GetAccessFlowV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAccessFlowV2Params(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessFlowV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessRequestParams is parameters of getAccessRequest operation.
type GetAccessRequestParams struct {
	ID string
}

func unpackGetAccessRequestParams(packed middleware.Parameters) (params GetAccessRequestParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAccessRequestParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessRequestParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessRequestDetailsParams is parameters of getAccessRequestDetails operation.
type GetAccessRequestDetailsParams struct {
	ID string
}

func unpackGetAccessRequestDetailsParams(packed middleware.Parameters) (params GetAccessRequestDetailsParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAccessRequestDetailsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessRequestDetailsParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessRequestEntitlementsV4Params is parameters of getAccessRequestEntitlementsV4 operation.
type GetAccessRequestEntitlementsV4Params struct {
	ID             string
	IntegrationIds OptNilStringArray
	Limit          OptInt32
	PageToken      OptNilString
	ResourceTypes  OptNilStringArray
	Statuses       OptNilStringArray
}

func unpackGetAccessRequestEntitlementsV4Params(packed middleware.Parameters) (params GetAccessRequestEntitlementsV4Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "integration_ids",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IntegrationIds = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resource_types",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceTypes = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "statuses",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Statuses = v.(OptNilStringArray)
		}
	}
	return params
}

func decodeGetAccessRequestEntitlementsV4Params(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessRequestEntitlementsV4Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: integration_ids.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "integration_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIntegrationIdsVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotIntegrationIdsValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotIntegrationIdsValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotIntegrationIdsVal = append(paramsDotIntegrationIdsVal, paramsDotIntegrationIdsValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.IntegrationIds.SetTo(paramsDotIntegrationIdsVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.IntegrationIds.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "integration_ids",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resource_types.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resource_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypesVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotResourceTypesValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotResourceTypesValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotResourceTypesVal = append(paramsDotResourceTypesVal, paramsDotResourceTypesValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.ResourceTypes.SetTo(paramsDotResourceTypesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ResourceTypes.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource_types",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: statuses.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "statuses",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusesVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotStatusesValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotStatusesValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotStatusesVal = append(paramsDotStatusesVal, paramsDotStatusesValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Statuses.SetTo(paramsDotStatusesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Statuses.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "statuses",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessRequestsV4Params is parameters of getAccessRequestsV4 operation.
type GetAccessRequestsV4Params struct {
	ID string
}

func unpackGetAccessRequestsV4Params(packed middleware.Parameters) (params GetAccessRequestsV4Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAccessRequestsV4Params(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessRequestsV4Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessScopesV1Params is parameters of getAccessScopesV1 operation.
type GetAccessScopesV1Params struct {
	ID string
}

func unpackGetAccessScopesV1Params(packed middleware.Parameters) (params GetAccessScopesV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAccessScopesV1Params(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessScopesV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessSessionAccessDetailsV1Params is parameters of getAccessSessionAccessDetailsV1 operation.
type GetAccessSessionAccessDetailsV1Params struct {
	ID string
}

func unpackGetAccessSessionAccessDetailsV1Params(packed middleware.Parameters) (params GetAccessSessionAccessDetailsV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAccessSessionAccessDetailsV1Params(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessSessionAccessDetailsV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccessSessionV1Params is parameters of getAccessSessionV1 operation.
type GetAccessSessionV1Params struct {
	ID string
}

func unpackGetAccessSessionV1Params(packed middleware.Parameters) (params GetAccessSessionV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAccessSessionV1Params(args [1]string, argsEscaped bool, r *http.Request) (params GetAccessSessionV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBundleV2Params is parameters of getBundleV2 operation.
type GetBundleV2Params struct {
	ID string
}

func unpackGetBundleV2Params(packed middleware.Parameters) (params GetBundleV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetBundleV2Params(args [1]string, argsEscaped bool, r *http.Request) (params GetBundleV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetConnectorV3Params is parameters of getConnectorV3 operation.
type GetConnectorV3Params struct {
	ID string
}

func unpackGetConnectorV3Params(packed middleware.Parameters) (params GetConnectorV3Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetConnectorV3Params(args [1]string, argsEscaped bool, r *http.Request) (params GetConnectorV3Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetGroupV1Params is parameters of getGroupV1 operation.
type GetGroupV1Params struct {
	ID string
}

func unpackGetGroupV1Params(packed middleware.Parameters) (params GetGroupV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetGroupV1Params(args [1]string, argsEscaped bool, r *http.Request) (params GetGroupV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetIntegrationConfigParams is parameters of getIntegrationConfig operation.
type GetIntegrationConfigParams struct {
	Type string
}

func unpackGetIntegrationConfigParams(packed middleware.Parameters) (params GetIntegrationConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "type",
			In:   "path",
		}
		params.Type = packed[key].(string)
	}
	return params
}

func decodeGetIntegrationConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params GetIntegrationConfigParams, _ error) {
	// Decode path: type.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Type = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "type",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetIntegrationPermissionsParams is parameters of getIntegrationPermissions operation.
type GetIntegrationPermissionsParams struct {
	ID           string
	ResourceType OptNilString
}

func unpackGetIntegrationPermissionsParams(packed middleware.Parameters) (params GetIntegrationPermissionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "resource-type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceType = v.(OptNilString)
		}
	}
	return params
}

func decodeGetIntegrationPermissionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetIntegrationPermissionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: resource-type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resource-type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceType.SetTo(paramsDotResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource-type",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetIntegrationResourcesParams is parameters of getIntegrationResources operation.
type GetIntegrationResourcesParams struct {
	ID           string
	ResourceType OptNilString
}

func unpackGetIntegrationResourcesParams(packed middleware.Parameters) (params GetIntegrationResourcesParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "resource-type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceType = v.(OptNilString)
		}
	}
	return params
}

func decodeGetIntegrationResourcesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetIntegrationResourcesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: resource-type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resource-type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceType.SetTo(paramsDotResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource-type",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetIntegrationV2Params is parameters of getIntegrationV2 operation.
type GetIntegrationV2Params struct {
	ID string
}

func unpackGetIntegrationV2Params(packed middleware.Parameters) (params GetIntegrationV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetIntegrationV2Params(args [1]string, argsEscaped bool, r *http.Request) (params GetIntegrationV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetIntegrationsByIdV4Params is parameters of getIntegrationsByIdV4 operation.
type GetIntegrationsByIdV4Params struct {
	ID string
}

func unpackGetIntegrationsByIdV4Params(packed middleware.Parameters) (params GetIntegrationsByIdV4Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetIntegrationsByIdV4Params(args [1]string, argsEscaped bool, r *http.Request) (params GetIntegrationsByIdV4Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetResourceUserTagsParams is parameters of getResourceUserTags operation.
type GetResourceUserTagsParams struct {
	ResourceID string
}

func unpackGetResourceUserTagsParams(packed middleware.Parameters) (params GetResourceUserTagsParams) {
	{
		key := middleware.ParameterKey{
			Name: "resource_id",
			In:   "path",
		}
		params.ResourceID = packed[key].(string)
	}
	return params
}

func decodeGetResourceUserTagsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetResourceUserTagsParams, _ error) {
	// Decode path: resource_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "resource_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ResourceID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSelectableIntegrationsParams is parameters of getSelectableIntegrations operation.
type GetSelectableIntegrationsParams struct {
	UserID OptNilString
}

func unpackGetSelectableIntegrationsParams(packed middleware.Parameters) (params GetSelectableIntegrationsParams) {
	{
		key := middleware.ParameterKey{
			Name: "user_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UserID = v.(OptNilString)
		}
	}
	return params
}

func decodeGetSelectableIntegrationsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetSelectableIntegrationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: user_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "user_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUserIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotUserIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UserID.SetTo(paramsDotUserIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "user_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetSelectablePermissionsParams is parameters of getSelectablePermissions operation.
type GetSelectablePermissionsParams struct {
	IntegrationID NilString
	ResourceType  string
	UserID        OptNilString
}

func unpackGetSelectablePermissionsParams(packed middleware.Parameters) (params GetSelectablePermissionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "integration_id",
			In:   "path",
		}
		params.IntegrationID = packed[key].(NilString)
	}
	{
		key := middleware.ParameterKey{
			Name: "resource_type",
			In:   "path",
		}
		params.ResourceType = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "user_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UserID = v.(OptNilString)
		}
	}
	return params
}

func decodeGetSelectablePermissionsParams(args [2]string, argsEscaped bool, r *http.Request) (params GetSelectablePermissionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: integration_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "integration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotIntegrationIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIntegrationIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IntegrationID.SetTo(paramsDotIntegrationIDVal)
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "integration_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: resource_type.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "resource_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ResourceType = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource_type",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: user_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "user_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUserIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotUserIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UserID.SetTo(paramsDotUserIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "user_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetSelectableResourceTypesParams is parameters of getSelectableResourceTypes operation.
type GetSelectableResourceTypesParams struct {
	IntegrationID NilString
	UserID        OptNilString
}

func unpackGetSelectableResourceTypesParams(packed middleware.Parameters) (params GetSelectableResourceTypesParams) {
	{
		key := middleware.ParameterKey{
			Name: "integration_id",
			In:   "path",
		}
		params.IntegrationID = packed[key].(NilString)
	}
	{
		key := middleware.ParameterKey{
			Name: "user_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UserID = v.(OptNilString)
		}
	}
	return params
}

func decodeGetSelectableResourceTypesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSelectableResourceTypesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: integration_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "integration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotIntegrationIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIntegrationIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IntegrationID.SetTo(paramsDotIntegrationIDVal)
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "integration_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: user_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "user_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUserIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotUserIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UserID.SetTo(paramsDotUserIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "user_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetSelectableResourcesParams is parameters of getSelectableResources operation.
type GetSelectableResourcesParams struct {
	IntegrationID NilString
	ResourceType  string
	UserID        OptNilString
}

func unpackGetSelectableResourcesParams(packed middleware.Parameters) (params GetSelectableResourcesParams) {
	{
		key := middleware.ParameterKey{
			Name: "integration_id",
			In:   "path",
		}
		params.IntegrationID = packed[key].(NilString)
	}
	{
		key := middleware.ParameterKey{
			Name: "resource_type",
			In:   "path",
		}
		params.ResourceType = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "user_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UserID = v.(OptNilString)
		}
	}
	return params
}

func decodeGetSelectableResourcesParams(args [2]string, argsEscaped bool, r *http.Request) (params GetSelectableResourcesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: integration_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "integration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotIntegrationIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIntegrationIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IntegrationID.SetTo(paramsDotIntegrationIDVal)
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "integration_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: resource_type.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "resource_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ResourceType = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource_type",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: user_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "user_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUserIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotUserIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UserID.SetTo(paramsDotUserIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "user_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetUserParams is parameters of getUser operation.
type GetUserParams struct {
	ID string
}

func unpackGetUserParams(packed middleware.Parameters) (params GetUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetUserParams(args [1]string, argsEscaped bool, r *http.Request) (params GetUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ListAccessFlowsV2Params is parameters of listAccessFlowsV2 operation.
type ListAccessFlowsV2Params struct {
	Limit     OptInt32
	PageToken OptNilString
}

func unpackListAccessFlowsV2Params(packed middleware.Parameters) (params ListAccessFlowsV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	return params
}

func decodeListAccessFlowsV2Params(args [0]string, argsEscaped bool, r *http.Request) (params ListAccessFlowsV2Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAccessRequestsParams is parameters of listAccessRequests operation.
type ListAccessRequestsParams struct {
	DaysOffset OptNilInt64
	UserID     OptNilString
}

func unpackListAccessRequestsParams(packed middleware.Parameters) (params ListAccessRequestsParams) {
	{
		key := middleware.ParameterKey{
			Name: "days_offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DaysOffset = v.(OptNilInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "user_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UserID = v.(OptNilString)
		}
	}
	return params
}

func decodeListAccessRequestsParams(args [0]string, argsEscaped bool, r *http.Request) (params ListAccessRequestsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: days_offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "days_offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDaysOffsetVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotDaysOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DaysOffset.SetTo(paramsDotDaysOffsetVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "days_offset",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: user_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "user_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUserIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotUserIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UserID.SetTo(paramsDotUserIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "user_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAccessRequestsV4Params is parameters of listAccessRequestsV4 operation.
type ListAccessRequestsV4Params struct {
	Limit     OptInt32
	PageToken OptNilString
	Statuses  OptNilStringArray
}

func unpackListAccessRequestsV4Params(packed middleware.Parameters) (params ListAccessRequestsV4Params) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "statuses",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Statuses = v.(OptNilStringArray)
		}
	}
	return params
}

func decodeListAccessRequestsV4Params(args [0]string, argsEscaped bool, r *http.Request) (params ListAccessRequestsV4Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: statuses.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "statuses",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusesVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotStatusesValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotStatusesValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotStatusesVal = append(paramsDotStatusesVal, paramsDotStatusesValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Statuses.SetTo(paramsDotStatusesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Statuses.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "statuses",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAccessScopesV1Params is parameters of listAccessScopesV1 operation.
type ListAccessScopesV1Params struct {
	Limit     OptInt32
	Name      OptNilString
	PageToken OptNilString
}

func unpackListAccessScopesV1Params(packed middleware.Parameters) (params ListAccessScopesV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	return params
}

func decodeListAccessScopesV1Params(args [0]string, argsEscaped bool, r *http.Request) (params ListAccessScopesV1Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAccessSessionsV1Params is parameters of listAccessSessionsV1 operation.
type ListAccessSessionsV1Params struct {
	Limit     OptInt32
	PageToken OptNilString
}

func unpackListAccessSessionsV1Params(packed middleware.Parameters) (params ListAccessSessionsV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	return params
}

func decodeListAccessSessionsV1Params(args [0]string, argsEscaped bool, r *http.Request) (params ListAccessSessionsV1Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListActivityParams is parameters of listActivity operation.
type ListActivityParams struct {
	EndDate             OptNilInt64
	Fields              OptNilReportFieldArray
	FilterIntegrationID OptNilStringArray
	FilterPermission    OptNilStringArray
	FilterRequestorID   OptNilStringArray
	FilterResource      OptNilStringArray
	FilterResourceType  OptNilStringArray
	FilterStatus        OptNilStringArray
	FilterTriggerType   OptNilStringArray
	StartDate           OptNilInt64
}

func unpackListActivityParams(packed middleware.Parameters) (params ListActivityParams) {
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptNilInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "fields",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Fields = v.(OptNilReportFieldArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "filter[integration_id]",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FilterIntegrationID = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "filter[permission]",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FilterPermission = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "filter[requestor_id]",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FilterRequestorID = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "filter[resource]",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FilterResource = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "filter[resource_type]",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FilterResourceType = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "filter[status]",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FilterStatus = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "filter[trigger_type]",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FilterTriggerType = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptNilInt64)
		}
	}
	return params
}

func decodeListActivityParams(args [0]string, argsEscaped bool, r *http.Request) (params ListActivityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: end_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_date",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: fields.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fields",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldsVal []ReportField
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotFieldsValVal ReportField
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotFieldsValVal = ReportField(c)
							return nil
						}(); err != nil {
							return err
						}
						paramsDotFieldsVal = append(paramsDotFieldsVal, paramsDotFieldsValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Fields.SetTo(paramsDotFieldsVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Fields.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						var failures []validate.FieldError
						for i, elem := range value {
							if err := func() error {
								if err := elem.Validate(); err != nil {
									return err
								}
								return nil
							}(); err != nil {
								failures = append(failures, validate.FieldError{
									Name:  fmt.Sprintf("[%d]", i),
									Error: err,
								})
							}
						}
						if len(failures) > 0 {
							return &validate.Error{Fields: failures}
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "fields",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: filter[integration_id].
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter[integration_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterIntegrationIDVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotFilterIntegrationIDValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotFilterIntegrationIDValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotFilterIntegrationIDVal = append(paramsDotFilterIntegrationIDVal, paramsDotFilterIntegrationIDValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.FilterIntegrationID.SetTo(paramsDotFilterIntegrationIDVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.FilterIntegrationID.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "filter[integration_id]",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: filter[permission].
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter[permission]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterPermissionVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotFilterPermissionValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotFilterPermissionValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotFilterPermissionVal = append(paramsDotFilterPermissionVal, paramsDotFilterPermissionValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.FilterPermission.SetTo(paramsDotFilterPermissionVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.FilterPermission.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "filter[permission]",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: filter[requestor_id].
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter[requestor_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterRequestorIDVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotFilterRequestorIDValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotFilterRequestorIDValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotFilterRequestorIDVal = append(paramsDotFilterRequestorIDVal, paramsDotFilterRequestorIDValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.FilterRequestorID.SetTo(paramsDotFilterRequestorIDVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.FilterRequestorID.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "filter[requestor_id]",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: filter[resource].
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter[resource]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterResourceVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotFilterResourceValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotFilterResourceValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotFilterResourceVal = append(paramsDotFilterResourceVal, paramsDotFilterResourceValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.FilterResource.SetTo(paramsDotFilterResourceVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.FilterResource.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "filter[resource]",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: filter[resource_type].
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter[resource_type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterResourceTypeVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotFilterResourceTypeValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotFilterResourceTypeValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotFilterResourceTypeVal = append(paramsDotFilterResourceTypeVal, paramsDotFilterResourceTypeValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.FilterResourceType.SetTo(paramsDotFilterResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.FilterResourceType.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "filter[resource_type]",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: filter[status].
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterStatusVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotFilterStatusValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotFilterStatusValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotFilterStatusVal = append(paramsDotFilterStatusVal, paramsDotFilterStatusValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.FilterStatus.SetTo(paramsDotFilterStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.FilterStatus.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "filter[status]",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: filter[trigger_type].
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter[trigger_type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterTriggerTypeVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotFilterTriggerTypeValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotFilterTriggerTypeValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotFilterTriggerTypeVal = append(paramsDotFilterTriggerTypeVal, paramsDotFilterTriggerTypeValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.FilterTriggerType.SetTo(paramsDotFilterTriggerTypeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.FilterTriggerType.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "filter[trigger_type]",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_date",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAttributesForIdentitiesParams is parameters of listAttributesForIdentities operation.
type ListAttributesForIdentitiesParams struct {
	Emails OptNilStringArray
	Limit  OptInt32
	Skip   OptInt32
}

func unpackListAttributesForIdentitiesParams(packed middleware.Parameters) (params ListAttributesForIdentitiesParams) {
	{
		key := middleware.ParameterKey{
			Name: "emails",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Emails = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "skip",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Skip = v.(OptInt32)
		}
	}
	return params
}

func decodeListAttributesForIdentitiesParams(args [0]string, argsEscaped bool, r *http.Request) (params ListAttributesForIdentitiesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: emails.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "emails",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEmailsVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotEmailsValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotEmailsValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotEmailsVal = append(paramsDotEmailsVal, paramsDotEmailsValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Emails.SetTo(paramsDotEmailsVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Emails.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "emails",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: skip.
	{
		val := int32(0)
		params.Skip.SetTo(val)
	}
	// Decode query: skip.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "skip",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSkipVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotSkipVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Skip.SetTo(paramsDotSkipVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "skip",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAvailableBundlesV1Params is parameters of listAvailableBundlesV1 operation.
type ListAvailableBundlesV1Params struct {
	Limit     OptInt32
	Name      OptNilStringArray
	PageToken OptNilString
}

func unpackListAvailableBundlesV1Params(packed middleware.Parameters) (params ListAvailableBundlesV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	return params
}

func decodeListAvailableBundlesV1Params(args [0]string, argsEscaped bool, r *http.Request) (params ListAvailableBundlesV1Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotNameValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotNameValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotNameVal = append(paramsDotNameVal, paramsDotNameValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Name.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAvailableEntitlementsV1Params is parameters of listAvailableEntitlementsV1 operation.
type ListAvailableEntitlementsV1Params struct {
	IntegrationID    OptNilStringArray
	IntegrationName  OptNilStringArray
	Limit            OptInt32
	PageToken        OptNilString
	PermissionName   OptNilStringArray
	ResourceName     OptNilStringArray
	ResourceSourceID OptNilStringArray
	ResourceTypeID   OptNilStringArray
}

func unpackListAvailableEntitlementsV1Params(packed middleware.Parameters) (params ListAvailableEntitlementsV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "integration_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IntegrationID = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "integration_name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IntegrationName = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "permission_name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PermissionName = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resource_name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceName = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resource_source_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceSourceID = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resource_type_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceTypeID = v.(OptNilStringArray)
		}
	}
	return params
}

func decodeListAvailableEntitlementsV1Params(args [0]string, argsEscaped bool, r *http.Request) (params ListAvailableEntitlementsV1Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: integration_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "integration_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIntegrationIDVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotIntegrationIDValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotIntegrationIDValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotIntegrationIDVal = append(paramsDotIntegrationIDVal, paramsDotIntegrationIDValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.IntegrationID.SetTo(paramsDotIntegrationIDVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.IntegrationID.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "integration_id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: integration_name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "integration_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIntegrationNameVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotIntegrationNameValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotIntegrationNameValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotIntegrationNameVal = append(paramsDotIntegrationNameVal, paramsDotIntegrationNameValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.IntegrationName.SetTo(paramsDotIntegrationNameVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.IntegrationName.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "integration_name",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: permission_name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "permission_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPermissionNameVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotPermissionNameValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotPermissionNameValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotPermissionNameVal = append(paramsDotPermissionNameVal, paramsDotPermissionNameValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.PermissionName.SetTo(paramsDotPermissionNameVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.PermissionName.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "permission_name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resource_name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resource_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceNameVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotResourceNameValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotResourceNameValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotResourceNameVal = append(paramsDotResourceNameVal, paramsDotResourceNameValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.ResourceName.SetTo(paramsDotResourceNameVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ResourceName.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource_name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resource_source_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resource_source_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceSourceIDVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotResourceSourceIDValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotResourceSourceIDValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotResourceSourceIDVal = append(paramsDotResourceSourceIDVal, paramsDotResourceSourceIDValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.ResourceSourceID.SetTo(paramsDotResourceSourceIDVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ResourceSourceID.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource_source_id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resource_type_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resource_type_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypeIDVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotResourceTypeIDValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotResourceTypeIDValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotResourceTypeIDVal = append(paramsDotResourceTypeIDVal, paramsDotResourceTypeIDValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.ResourceTypeID.SetTo(paramsDotResourceTypeIDVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ResourceTypeID.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource_type_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListBundlesV2Params is parameters of listBundlesV2 operation.
type ListBundlesV2Params struct {
	Limit     OptInt32
	Name      OptNilString
	PageToken OptNilString
}

func unpackListBundlesV2Params(packed middleware.Parameters) (params ListBundlesV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	return params
}

func decodeListBundlesV2Params(args [0]string, argsEscaped bool, r *http.Request) (params ListBundlesV2Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListConnectorsV3Params is parameters of listConnectorsV3 operation.
type ListConnectorsV3Params struct {
	Limit     OptInt32
	PageToken OptNilString
	Status    OptNilStringArray
}

func unpackListConnectorsV3Params(packed middleware.Parameters) (params ListConnectorsV3Params) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptNilStringArray)
		}
	}
	return params
}

func decodeListConnectorsV3Params(args [0]string, argsEscaped bool, r *http.Request) (params ListConnectorsV3Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotStatusValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotStatusValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotStatusVal = append(paramsDotStatusVal, paramsDotStatusValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListGroupMembersV1Params is parameters of listGroupMembersV1 operation.
type ListGroupMembersV1Params struct {
	ID        string
	Limit     OptInt32
	PageToken OptNilString
}

func unpackListGroupMembersV1Params(packed middleware.Parameters) (params ListGroupMembersV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	return params
}

func decodeListGroupMembersV1Params(args [1]string, argsEscaped bool, r *http.Request) (params ListGroupMembersV1Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListGroupsV1Params is parameters of listGroupsV1 operation.
type ListGroupsV1Params struct {
	Limit     OptInt32
	Name      OptNilString
	PageToken OptNilString
}

func unpackListGroupsV1Params(packed middleware.Parameters) (params ListGroupsV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	return params
}

func decodeListGroupsV1Params(args [0]string, argsEscaped bool, r *http.Request) (params ListGroupsV1Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListIntegrationsV4Params is parameters of listIntegrationsV4 operation.
type ListIntegrationsV4Params struct {
	Category    OptNilStringArray
	ConnectorID OptNilStringArray
	Limit       OptInt32
	Name        OptNilString
	PageToken   OptNilString
	Status      OptNilStringArray
	Type        OptNilStringArray
}

func unpackListIntegrationsV4Params(packed middleware.Parameters) (params ListIntegrationsV4Params) {
	{
		key := middleware.ParameterKey{
			Name: "category",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Category = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "connector_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ConnectorID = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page_token",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageToken = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Type = v.(OptNilStringArray)
		}
	}
	return params
}

func decodeListIntegrationsV4Params(args [0]string, argsEscaped bool, r *http.Request) (params ListIntegrationsV4Params, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: category.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCategoryVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotCategoryValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotCategoryValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotCategoryVal = append(paramsDotCategoryVal, paramsDotCategoryValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Category.SetTo(paramsDotCategoryVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Category.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "category",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: connector_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "connector_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotConnectorIDVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotConnectorIDValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotConnectorIDValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotConnectorIDVal = append(paramsDotConnectorIDVal, paramsDotConnectorIDValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.ConnectorID.SetTo(paramsDotConnectorIDVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ConnectorID.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "connector_id",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: page_token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageToken.SetTo(paramsDotPageTokenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page_token",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotStatusValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotStatusValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotStatusVal = append(paramsDotStatusVal, paramsDotStatusValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotTypeValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotTypeValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotTypeVal = append(paramsDotTypeVal, paramsDotTypeValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Type.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "type",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// RefreshIntegrationV2Params is parameters of refreshIntegrationV2 operation.
type RefreshIntegrationV2Params struct {
	ID string
}

func unpackRefreshIntegrationV2Params(packed middleware.Parameters) (params RefreshIntegrationV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRefreshIntegrationV2Params(args [1]string, argsEscaped bool, r *http.Request) (params RefreshIntegrationV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveGroupMemberV1Params is parameters of removeGroupMemberV1 operation.
type RemoveGroupMemberV1Params struct {
	Email string
	ID    string
}

func unpackRemoveGroupMemberV1Params(packed middleware.Parameters) (params RemoveGroupMemberV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "email",
			In:   "path",
		}
		params.Email = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRemoveGroupMemberV1Params(args [2]string, argsEscaped bool, r *http.Request) (params RemoveGroupMemberV1Params, _ error) {
	// Decode path: email.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "email",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Email = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "email",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RequestAccessAgainV4Params is parameters of requestAccessAgainV4 operation.
type RequestAccessAgainV4Params struct {
	ID string
}

func unpackRequestAccessAgainV4Params(packed middleware.Parameters) (params RequestAccessAgainV4Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRequestAccessAgainV4Params(args [1]string, argsEscaped bool, r *http.Request) (params RequestAccessAgainV4Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ResetAccessRequestCredentialsParams is parameters of resetAccessRequestCredentials operation.
type ResetAccessRequestCredentialsParams struct {
	ID string
}

func unpackResetAccessRequestCredentialsParams(packed middleware.Parameters) (params ResetAccessRequestCredentialsParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeResetAccessRequestCredentialsParams(args [1]string, argsEscaped bool, r *http.Request) (params ResetAccessRequestCredentialsParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ResetAccessSessionCredentialsV1Params is parameters of resetAccessSessionCredentialsV1 operation.
type ResetAccessSessionCredentialsV1Params struct {
	ID string
}

func unpackResetAccessSessionCredentialsV1Params(packed middleware.Parameters) (params ResetAccessSessionCredentialsV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeResetAccessSessionCredentialsV1Params(args [1]string, argsEscaped bool, r *http.Request) (params ResetAccessSessionCredentialsV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RevokeAccessRequestV4Params is parameters of revokeAccessRequestV4 operation.
type RevokeAccessRequestV4Params struct {
	ID string
}

func unpackRevokeAccessRequestV4Params(packed middleware.Parameters) (params RevokeAccessRequestV4Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRevokeAccessRequestV4Params(args [1]string, argsEscaped bool, r *http.Request) (params RevokeAccessRequestV4Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateAccessBundleParams is parameters of updateAccessBundle operation.
type UpdateAccessBundleParams struct {
	ID string
}

func unpackUpdateAccessBundleParams(packed middleware.Parameters) (params UpdateAccessBundleParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateAccessBundleParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateAccessBundleParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateAccessFlowV1Params is parameters of updateAccessFlowV1 operation.
type UpdateAccessFlowV1Params struct {
	ID string
}

func unpackUpdateAccessFlowV1Params(packed middleware.Parameters) (params UpdateAccessFlowV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateAccessFlowV1Params(args [1]string, argsEscaped bool, r *http.Request) (params UpdateAccessFlowV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateAccessFlowV2Params is parameters of updateAccessFlowV2 operation.
type UpdateAccessFlowV2Params struct {
	ID string
}

func unpackUpdateAccessFlowV2Params(packed middleware.Parameters) (params UpdateAccessFlowV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateAccessFlowV2Params(args [1]string, argsEscaped bool, r *http.Request) (params UpdateAccessFlowV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateAccessScopesV1Params is parameters of updateAccessScopesV1 operation.
type UpdateAccessScopesV1Params struct {
	ID string
}

func unpackUpdateAccessScopesV1Params(packed middleware.Parameters) (params UpdateAccessScopesV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateAccessScopesV1Params(args [1]string, argsEscaped bool, r *http.Request) (params UpdateAccessScopesV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateBundleV2Params is parameters of updateBundleV2 operation.
type UpdateBundleV2Params struct {
	ID string
}

func unpackUpdateBundleV2Params(packed middleware.Parameters) (params UpdateBundleV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateBundleV2Params(args [1]string, argsEscaped bool, r *http.Request) (params UpdateBundleV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateConnectorV3Params is parameters of updateConnectorV3 operation.
type UpdateConnectorV3Params struct {
	ID string
}

func unpackUpdateConnectorV3Params(packed middleware.Parameters) (params UpdateConnectorV3Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateConnectorV3Params(args [1]string, argsEscaped bool, r *http.Request) (params UpdateConnectorV3Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateGroupMembersV1Params is parameters of updateGroupMembersV1 operation.
type UpdateGroupMembersV1Params struct {
	ID string
}

func unpackUpdateGroupMembersV1Params(packed middleware.Parameters) (params UpdateGroupMembersV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateGroupMembersV1Params(args [1]string, argsEscaped bool, r *http.Request) (params UpdateGroupMembersV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateGroupV1Params is parameters of updateGroupV1 operation.
type UpdateGroupV1Params struct {
	ID string
}

func unpackUpdateGroupV1Params(packed middleware.Parameters) (params UpdateGroupV1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateGroupV1Params(args [1]string, argsEscaped bool, r *http.Request) (params UpdateGroupV1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateIntegrationV2Params is parameters of updateIntegrationV2 operation.
type UpdateIntegrationV2Params struct {
	ID string
}

func unpackUpdateIntegrationV2Params(packed middleware.Parameters) (params UpdateIntegrationV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateIntegrationV2Params(args [1]string, argsEscaped bool, r *http.Request) (params UpdateIntegrationV2Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateIntegrationV4Params is parameters of updateIntegrationV4 operation.
type UpdateIntegrationV4Params struct {
	ID string
}

func unpackUpdateIntegrationV4Params(packed middleware.Parameters) (params UpdateIntegrationV4Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateIntegrationV4Params(args [1]string, argsEscaped bool, r *http.Request) (params UpdateIntegrationV4Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateResourceUserTagsParams is parameters of updateResourceUserTags operation.
type UpdateResourceUserTagsParams struct {
	ResourceID string
}

func unpackUpdateResourceUserTagsParams(packed middleware.Parameters) (params UpdateResourceUserTagsParams) {
	{
		key := middleware.ParameterKey{
			Name: "resource_id",
			In:   "path",
		}
		params.ResourceID = packed[key].(string)
	}
	return params
}

func decodeUpdateResourceUserTagsParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateResourceUserTagsParams, _ error) {
	// Decode path: resource_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "resource_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ResourceID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
